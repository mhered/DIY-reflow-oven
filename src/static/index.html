<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Temperature Dashboard</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let interval = null;
    let temperatureInterval = null;
    let temperatureChart = null;

    // Simple state-driven UI update based on ProfileManager state
    function updateUIState(uiState) {
      console.log('Updating UI state:', uiState);
      
      // Enable/disable buttons based on ProfileManager state
      const profileSelect = document.getElementById('profileSelect');
      const toggleFormBtn = document.getElementById('toggleFormBtn');
      const playBtn = document.getElementById('playBtn');
      const stopBtn = document.getElementById('stopBtn');
      const clearBtn = document.getElementById('clearBtn');
      
      // Apply CSS classes for styling and disable functionality
      profileSelect.disabled = !uiState.can_select;
      profileSelect.className = uiState.can_select ? '' : 'disabled';
      
      // For buttons, use CSS classes instead of disabled attribute to maintain custom styling
      toggleFormBtn.className = uiState.can_create ? 'control-btn' : 'control-btn disabled';
      playBtn.className = uiState.can_run ? 'control-btn' : 'control-btn disabled';
      stopBtn.className = uiState.can_stop ? 'control-btn' : 'control-btn disabled';
      clearBtn.className = uiState.can_clear ? 'control-btn' : 'control-btn disabled';
      
      // Update tooltips based on state
      profileSelect.title = uiState.can_select ? "Select a temperature profile to activate" : "Cannot select profile while one is active";
      toggleFormBtn.title = uiState.can_create ? "Create a new temperature profile" : "Cannot create profile while one is active or running";
      playBtn.title = uiState.can_run ? "Run the active profile" : "Select a profile first to enable running";
      stopBtn.title = uiState.can_stop ? "Stop the running profile" : "No profile is currently running";
      clearBtn.title = uiState.can_clear ? "Clear graph data and deactivate profile" : "No profile data to clear";
      
      // Show/hide graph and timer based on state
      const timerDiv = document.getElementById("profileTimer");
      if (uiState.show_graph && uiState.active_profile_name) {
        timerDiv.style.display = "block";
        showTemperatureGraph();
        loadProfileForGraph(uiState.active_profile_name);
      } else if (!uiState.show_graph) {
        timerDiv.style.display = "none";
        hideTemperatureGraph();
      }
      
      // Temperature data updates - start/stop based on running state
      if (uiState.is_running) {
        if (!temperatureInterval) {
          // Start interval and call immediately
          updateMeasuredTemperature();
          temperatureInterval = setInterval(updateMeasuredTemperature, 5000); // Reduced to 5 seconds
        }
      } else {
        if (temperatureInterval) {
          clearInterval(temperatureInterval);
          temperatureInterval = null;
        }
      }
      
      // Update profile selector to show active profile
      if (uiState.active_profile_name && profileSelect.value !== uiState.active_profile_name) {
        profileSelect.value = uiState.active_profile_name;
      } else if (!uiState.active_profile_name) {
        profileSelect.value = '';
      }
    }

    function updateTemp() {
      fetch('/temperature')
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          console.log('Temperature data received:', data); // Debug log
          
          // Update temperature display with proper fallbacks
          const currentTemp = data.temp !== undefined && data.temp !== null ? data.temp : '--';
          document.getElementById("currentTemp").innerText = currentTemp + (currentTemp !== '--' ? ' ¬∞C' : '');
          
          // Display target temperature or "--" if not set
          const targetTemp = data.target !== undefined && data.target !== null ? data.target : '--';
          const targetDisplay = targetTemp !== '--' ? targetTemp + " ¬∞C" : "--";
          document.getElementById("currentTarget").innerText = targetDisplay;

          // Simple state-driven UI updates using ProfileManager ui_state
          if (data.ui_state) {
            updateUIState(data.ui_state);
          }

          // Update profile status using ui_state
          try {
            if (data.ui_state && typeof data.ui_state === 'object') {
              const status = data.ui_state;
              const statusText = status.is_running ? 
                `Running: ${status.active_profile_name || 'Unknown'} (${status.current_phase || 'Unknown'})` : 
                (status.active_profile_name ? `Stopped: ${status.active_profile_name}` : 'No Profile Selected');
              document.getElementById("profileStatus").innerText = statusText;
              
              // Update timer fields if profile is active
              if (status.active_profile_name) {
                // Format time as MM:SS
                const formatTime = (minutes) => {
                  const mins = Math.floor(minutes);
                  const secs = Math.floor((minutes - mins) * 60);
                  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                };
                
                document.getElementById("elapsedTime").innerText = formatTime(status.elapsed_minutes || 0);
                
                const remaining = Math.max(0, (status.total_minutes || 0) - (status.elapsed_minutes || 0));
                document.getElementById("remainingTime").innerText = formatTime(remaining);
                
                // Update progress bar
                const progressFill = document.getElementById("progressFill");
                progressFill.style.width = `${status.progress_percent || 0}%`;
              }
            } else {
              // No profile status - ensure we show "No Profile Selected"
              document.getElementById("profileStatus").innerText = 'No Profile Selected';
            }
          } catch (error) {
            console.warn('Profile status update error:', error);
            document.getElementById("profileStatus").innerText = 'No Profile Selected';
          }

          // Update heater icon
          try {
            const heaterIcon = document.getElementById("heaterStatus");
            if (data.heater_on) {
              heaterIcon.style.display = "inline";
            } else {
              heaterIcon.style.display = "none";
            }
          } catch (error) {
            console.warn('Heater status update error:', error);
          }
        })
        .catch(error => {
          console.error('Error fetching temperature:', error);
          
          // Show user-friendly error messages
          if (error.message.includes('HTTP 404')) {
            document.getElementById("profileStatus").innerText = "Server not configured";
          } else if (error.message.includes('HTTP 500')) {
            document.getElementById("profileStatus").innerText = "Server error";
          } else if (error.message.includes('fetch') || error.name === 'TypeError') {
            document.getElementById("profileStatus").innerText = "Device offline";
            document.getElementById("currentTemp").innerText = "--";
            document.getElementById("currentTarget").innerText = "--";
          } else {
            // For parsing or other errors, show specific error but keep trying
            console.warn('Temperature data parsing error:', error.message);
            document.getElementById("profileStatus").innerText = "Data error";
          }
        });
    }

    function loadProfiles() {
      return fetch('/profiles')
        .then(res => res.json())
        .then(data => {
          if (data.status === 'ok') {
            const select = document.getElementById("profileSelect");
            // Clear existing options except the first one
            select.innerHTML = '<option value="">Select a profile...</option>';
            
            // Add each profile as an option
            data.profiles.forEach(profile => {
              const option = document.createElement("option");
              option.value = profile;
              option.textContent = profile;
              select.appendChild(option);
            });
          } else {
            console.error('Profiles response error:', data);
          }
        })
        .catch(error => {
          console.error('Error loading profiles:', error);
          throw error; // Re-throw so retry logic can catch it
        });
    }

    function startProfile() {
      const playBtn = document.getElementById("playBtn");
      if (playBtn.classList.contains('disabled')) {
        return; // Don't execute if disabled
      }
      
      const select = document.getElementById("profileSelect");
      const profileName = select.value;
      
      if (!profileName) {
        showFeedback('Please select a profile first', 'error');
        return;
      }
      
      // Use the updated start endpoint
      fetch(`/profile/${encodeURIComponent(profileName)}/start`, { method: 'POST' })
        .then(res => res.json())
        .then(data => {
          if (data.status === 'ok') {
            showFeedback(data.message, 'success');
            console.log('Profile started:', profileName);
            // UI updates will be handled automatically by updateUIState via temperature polling
          } else {
            showFeedback(data.message || 'Error starting profile', 'error');
          }
        })
        .catch(error => {
          console.error('Error starting profile:', error);
          showFeedback('Network error starting profile', 'error');
        });
    }

    function stopProfile() {
      const stopBtn = document.getElementById("stopBtn");
      if (stopBtn.classList.contains('disabled')) {
        return; // Don't execute if disabled
      }
      
      console.log('Stop button clicked');
      fetch('/profile/stop', { method: 'POST' })
        .then(response => {
          if (!response.ok) {
            return response.text().then(text => {
              throw new Error(`HTTP ${response.status}: ${text}`);
            });
          }
          return response.json();
        })
        .then(data => {
          console.log('Profile stopped successfully:', data);
          showFeedback(data.message || 'Profile stopped', 'success');
          // UI updates will be handled automatically by updateUIState via temperature polling
        })
        .catch(error => {
          console.error('Error stopping profile:', error);
          showFeedback('Network error stopping profile', 'error');
        });
    }

    function clearGraph() {
      const clearBtn = document.getElementById("clearBtn");
      if (clearBtn.classList.contains('disabled')) {
        return; // Don't execute if disabled
      }
      
      // Use the new unified clear endpoint
      fetch('/profile/clear', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
          if (data.status === 'ok') {
            console.log('Profile cleared:', data);
            showFeedback('Graph cleared', 'success');
          } else {
            throw new Error(data.message || 'Unknown error');
          }
          // UI updates will be handled automatically by updateUIState via temperature polling
        })
        .catch(error => {
          console.error('Error clearing graph:', error);
          showFeedback('Error clearing graph', 'error');
        });
    }

    let phaseCounter = 0;

    function toggleProfileForm() {
      const toggleFormBtn = document.getElementById("toggleFormBtn");
      if (toggleFormBtn.classList.contains('disabled')) {
        return; // Don't execute if disabled
      }
      
      const form = document.getElementById("profileForm");
      const btn = document.getElementById("toggleFormBtn");
      
      if (form.style.display === "none") {
        form.style.display = "block";
        btn.textContent = "Hide Form";
        // Add initial phase
        if (document.getElementById("phasesList").children.length === 0) {
          addPhase();
        }
      } else {
        form.style.display = "none";
        btn.textContent = "Create New Profile";
      }
    }

    function addPhase() {
      phaseCounter++;
      const phasesList = document.getElementById("phasesList");
      
      const phaseDiv = document.createElement("div");
      phaseDiv.className = "phase-item";
      phaseDiv.innerHTML = `
        <h5>Phase ${phaseCounter}</h5>
        <div class="phase-fields">
          <div class="field-group">
            <label>Name:</label>
            <input type="text" class="phase-name" placeholder="Phase name" value="Phase ${phaseCounter}">
          </div>
          <div class="field-group">
            <label>Start Temp (¬∞C):</label>
            <input type="number" class="phase-start-temp" placeholder="25" step="0.1">
          </div>
          <div class="field-group">
            <label>End Temp (¬∞C):</label>
            <input type="number" class="phase-end-temp" placeholder="50" step="0.1">
          </div>
          <div class="field-group">
            <label>Duration (minutes):</label>
            <input type="number" class="phase-duration" placeholder="5" step="0.1" min="0.1">
          </div>
          <button type="button" onclick="removePhase(this)" class="remove-phase-btn">Remove</button>
        </div>
      `;
      
      phasesList.appendChild(phaseDiv);
    }

    function removePhase(button) {
      button.closest('.phase-item').remove();
    }

    function saveProfile() {
      const profileName = document.getElementById("profileName").value.trim();
      
      if (!profileName) {
        showFeedback('Please enter a profile name', 'error');
        return;
      }
      
      // Collect phase data
      const phaseItems = document.querySelectorAll('.phase-item');
      const phases = [];
      
      for (let i = 0; i < phaseItems.length; i++) {
        const item = phaseItems[i];
        const name = item.querySelector('.phase-name').value.trim();
        const startTemp = parseFloat(item.querySelector('.phase-start-temp').value);
        const endTemp = parseFloat(item.querySelector('.phase-end-temp').value);
        const duration = parseFloat(item.querySelector('.phase-duration').value);
        
        if (!name || isNaN(startTemp) || isNaN(endTemp) || isNaN(duration) || duration <= 0) {
          showFeedback(`Please fill all fields for ${name || 'Phase ' + (i + 1)}`, 'error');
          return;
        }
        
        phases.push({
          name: name,
          start_temp: startTemp,
          end_temp: endTemp,
          duration_minutes: duration,
          type: 'time_based'
        });
      }
      
      if (phases.length === 0) {
        showFeedback('Please add at least one phase', 'error');
        return;
      }
      
      // Send to server using individual parameters for MicroPython URL limits
      let url = '/profile/create?name=' + encodeURIComponent(profileName);
      
      // Add each phase as separate parameters
      for (let i = 0; i < phases.length; i++) {
        const phase = phases[i];
        url += '&phase_' + i + '_name=' + encodeURIComponent(phase.name);
        url += '&phase_' + i + '_start=' + phase.start_temp;
        url += '&phase_' + i + '_end=' + phase.end_temp;
        url += '&phase_' + i + '_duration=' + phase.duration_minutes;
      }
      
      fetch(url)
      .then(res => res.json())
      .then(data => {
        if (data.status === 'ok') {
          showFeedback('Profile created successfully!', 'success');
          cancelProfileForm();
          
          // Simple approach: wait a bit and reload profiles
          setTimeout(() => {
            loadProfiles().then(() => {
              const select = document.getElementById("profileSelect");
              
              // Check if our new profile appears in the dropdown
              const profileExists = Array.from(select.options).some(option => 
                option.value === profileName
              );
              
              if (!profileExists) {
                console.warn('New profile not immediately visible in dropdown');
              }
            }).catch(error => {
              console.error('Error reloading profiles:', error);
              showFeedback('Error refreshing profile list', 'error');
            });
          }, 300);
          
        } else {
          showFeedback(data.message || 'Error creating profile', 'error');
        }
      })
      .catch(error => {
        console.error('Error creating profile:', error);
        showFeedback('Network error creating profile', 'error');
      });
    }

    function cancelProfileForm() {
      document.getElementById("profileForm").style.display = "none";
      document.getElementById("toggleFormBtn").textContent = "Create New Profile";
      
      // Clear form
      document.getElementById("profileName").value = "";
      document.getElementById("phasesList").innerHTML = "";
      phaseCounter = 0;
    }

    function showFeedback(message, type) {
      // Create or update feedback element
      let feedback = document.getElementById("feedback");
      if (!feedback) {
        feedback = document.createElement("div");
        feedback.id = "feedback";
        feedback.style.cssText = `
          margin: 10px 0;
          padding: 10px;
          border-radius: 4px;
          text-align: center;
          font-weight: bold;
        `;
        document.querySelector(".container").appendChild(feedback);
      }
      
      feedback.textContent = message;
      feedback.className = type; // 'success', 'error', or 'info'
      
      if (type === 'success') {
        feedback.style.backgroundColor = '#d4edda';
        feedback.style.color = '#155724';
        feedback.style.border = '1px solid #c3e6cb';
      } else if (type === 'info') {
        feedback.style.backgroundColor = '#d1ecf1';
        feedback.style.color = '#0c5460';
        feedback.style.border = '1px solid #bee5eb';
      } else {
        feedback.style.backgroundColor = '#f8d7da';
        feedback.style.color = '#721c24';
        feedback.style.border = '1px solid #f5c6cb';
      }
      
      // Clear feedback after 3 seconds
      setTimeout(() => {
        feedback.textContent = '';
        feedback.style.display = 'none';
      }, 3000);
      
      feedback.style.display = 'block';
    }

    // Temperature graphing functionality
    let profileData = null;

    function createTemperatureChart() {
      const ctx = document.getElementById('temperatureChart').getContext('2d');
      
      temperatureChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Target',
            data: [],
            borderColor: 'rgb(255, 99, 132)',
            backgroundColor: 'rgba(255, 99, 132, 0.1)',
            borderWidth: 1.5,
            fill: false,
            pointRadius: 0,
            tension: 0.1
          }, {
            label: 'Measured',
            data: [],
            borderColor: 'rgb(54, 162, 235)',
            backgroundColor: 'rgba(54, 162, 235, 0.1)',
            borderWidth: 1.5,
            fill: false,
            pointRadius: 1,
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              top: 5,
              right: 5,
              bottom: 5,
              left: 5
            }
          },
          scales: {
            x: {
              type: 'linear',
              position: 'bottom',
              title: {
                display: false  // Hide the default title
              },
              ticks: {
                font: {
                  size: 9
                }
              },
              grid: {
                display: true,
                lineWidth: 0.5
              }
            },
            y: {
              title: {
                display: true,
                text: '¬∞C',
                font: {
                  size: 10
                }
              },
              ticks: {
                font: {
                  size: 9
                }
              },
              grid: {
                display: true,
                lineWidth: 0.5
              }
            }
          },
          plugins: {
            legend: {
              display: false  // We'll draw custom legend
            }
          }
        }
      });
      
      // Add custom legend and time axis label inside the chart
      Chart.register({
        id: 'customLabels',
        afterDraw: function(chart) {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          
          ctx.save();
          ctx.font = '9px Segoe UI, Roboto, sans-serif';
          ctx.fillStyle = '#666';
          
          // Draw time label in bottom right
          ctx.textAlign = 'right';
          ctx.textBaseline = 'bottom';
          ctx.fillText('Time (min)', chartArea.right - 5, chartArea.bottom - 2);
          
          // Draw custom legend in top left
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          
          const legendY = chartArea.top + 5;
          const legendX = chartArea.left + 5;
          
          // Target line legend
          ctx.strokeStyle = 'rgb(255, 99, 132)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(legendX, legendY + 5);
          ctx.lineTo(legendX + 15, legendY + 5);
          ctx.stroke();
          ctx.fillText('Target', legendX + 20, legendY);
          
          // Measured line legend
          ctx.strokeStyle = 'rgb(54, 162, 235)';
          ctx.beginPath();
          ctx.moveTo(legendX + 70, legendY + 5);
          ctx.lineTo(legendX + 85, legendY + 5);
          ctx.stroke();
          ctx.fillText('Measured', legendX + 90, legendY);
          
          ctx.restore();
        }
      });
    }

    function loadProfileForGraph(profileName) {
      fetch('/profile/data?name=' + encodeURIComponent(profileName))
        .then(res => {
          if (!res.ok) {
            throw new Error('Network response was not ok');
          }
          return res.json();
        })
        .then(data => {
          if (data.status === 'ok') {
            profileData = data.data;
            updateProfileGraph();
          } else {
            console.error('Profile data error:', data.message);
          }
        })
        .catch(error => {
          console.warn('Profile data loading failed:', error.message);
          // Hide graph if we can't load profile data
          hideTemperatureGraph();
        });
    }

    function updateProfileGraph() {
      if (!temperatureChart || !profileData) return;

      // Update target temperature line
      const targetData = profileData.points.map(point => ({
        x: point.time,
        y: point.temperature
      }));
      
      temperatureChart.data.datasets[0].data = targetData;
      temperatureChart.update('none');
    }

    function updateMeasuredTemperature() {
      if (!temperatureChart) return;

      fetch('/temperature/data')
        .then(res => {
          if (!res.ok) {
            throw new Error('Network response was not ok');
          }
          return res.json();
        })
        .then(data => {
          if (data.status === 'ok' && data.profile_active) {
            const measuredData = data.data.map(point => ({
              x: point.time,
              y: point.temperature
            }));
            
            temperatureChart.data.datasets[1].data = measuredData;
            temperatureChart.update('none');
          } else if (!data.profile_active) {
            // Just clear measured data when profile is not active, don't hide graph
            temperatureChart.data.datasets[1].data = [];
            temperatureChart.update('none');
            // Don't call hideTemperatureGraph() here - let handleGraphSync manage it
          }
        })
        .catch(error => {
          console.warn('Temperature data update failed (will retry):', error.message);
          // Don't show user error for this - just log and continue
        });
    }

    function showTemperatureGraph() {
      document.getElementById('temperatureGraphContainer').style.display = 'block';
    }

    function hideTemperatureGraph() {
      document.getElementById('temperatureGraphContainer').style.display = 'none';
      if (temperatureChart) {
        temperatureChart.data.datasets[0].data = [];
        temperatureChart.data.datasets[1].data = [];
        temperatureChart.update('none');
      }
      profileData = null;
    }

    window.onload = () => {
      // Test basic connectivity first
      console.log('Testing server connectivity...');
      fetch('/temperature')
        .then(res => {
          console.log('Server response status:', res.status);
          if (res.ok) {
            console.log('Server connectivity: OK');
            // Server is working, start normal operations
            updateTemp();
            loadProfiles();
            createTemperatureChart();
            interval = setInterval(updateTemp, 2000);
            
            // Add profile selection listener for activation
            const profileSelect = document.getElementById('profileSelect');
            profileSelect.addEventListener('change', function() {
              const selectedProfile = this.value;
              if (selectedProfile) {
                // Activate the selected profile
                fetch(`/profile/${encodeURIComponent(selectedProfile)}/activate`, { method: 'POST' })
                  .then(res => res.json())
                  .then(data => {
                    if (data.status === 'ok') {
                      console.log('Profile activated:', selectedProfile);
                      showFeedback(`Profile "${selectedProfile}" selected`, 'success');
                    } else {
                      console.error('Profile activation failed:', data.message);
                      showFeedback(data.message || 'Error selecting profile', 'error');
                    }
                  })
                  .catch(error => {
                    console.error('Error activating profile:', error);
                    showFeedback('Network error selecting profile', 'error');
                  });
              } else {
                // Deactivate if no profile selected
                fetch('/profile/deactivate', { method: 'POST' })
                  .then(res => res.json())
                  .then(data => {
                    console.log('Profile deactivated');
                  })
                  .catch(error => {
                    console.error('Error deactivating profile:', error);
                  });
              }
            });
          } else {
            console.error('Server connectivity: FAILED - HTTP', res.status);
            document.getElementById("profileStatus").innerText = `Server Error ${res.status}`;
            document.getElementById("currentTemp").innerText = "--";
            document.getElementById("currentTarget").innerText = "--";
          }
        })
        .catch(error => {
          console.error('Server connectivity: FAILED -', error.message);
          document.getElementById("profileStatus").innerText = 'Device Offline - Check MicroPython';
          document.getElementById("currentTemp").innerText = "--";
          document.getElementById("currentTarget").innerText = "--";
          
          // Try to start basic chart anyway for when server comes online
          createTemperatureChart();
        });
    };
  </script>
</head>

<body>
  <div class="container">
    <h1>Temperature</h1>
  
    <div class="temperature-display">
      <div class="temp-section">
        <div class="temp-value">
          <span id="currentTemp">--</span>
          <span id="heaterStatus">üî•</span>
        </div>
        <div class="temp-label">Current</div>
      </div>
      
      <div class="target-section">
        <div class="temp-value">
          <span id="currentTarget">--</span>
        </div>
        <div class="temp-label">Target</div>
      </div>
    </div>

    <div class="profile-section">
      <h2>Temperature Profile Status:</h2>
      
      <div class="profile-status">
        <label><span id="profileStatus">--</span></label>
        <div id="profileTimer" class="profile-timer" style="display: none;">
          <div class="timer-row">
            <span class="timer-label">Elapsed:</span>
            <span id="elapsedTime">--</span>
          </div>
          <div class="timer-row">
            <span class="timer-label">Remaining:</span>
            <span id="remainingTime">--</span>
          </div>
          <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          
          <!-- Temperature Graph integrated in the same section -->
          <div id="temperatureGraphContainer" class="temperature-graph-compact" style="display: none;">
            <div class="chart-container-compact">
              <canvas id="temperatureChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      
      
      <div class="profile-controls">
        <div class="control-buttons-row">
          <select id="profileSelect" title="Select a temperature profile to activate">
            <option value="">üîΩ Select a profile...</option>
          </select>
          <button onclick="toggleProfileForm()" id="toggleFormBtn" class="control-btn" title="Create a new temperature profile">‚ûï</button>
          <button onclick="startProfile()" id="playBtn" class="control-btn" title="Run the active profile">‚ñ∂Ô∏è</button>
          <button onclick="stopProfile()" id="stopBtn" class="control-btn" title="Stop the running profile">‚èπÔ∏è</button>
          <button onclick="clearGraph()" id="clearBtn" class="control-btn" title="Clear graph data and deactivate profile">‚úñÔ∏è</button>
        </div>
      </div>
      
      <div class="profile-creator">
        <div id="profileForm" class="profile-form" style="display: none;">
          <h3>Create New Profile</h3>
          
          <div class="form-group">
            <label for="profileName">Profile Name:</label>
            <input type="text" id="profileName" placeholder="Enter profile name">
          </div>
          
          <div class="phases-container">
            <h4>Phases:</h4>
            <div id="phasesList">
              <!-- Phases will be added here dynamically -->
            </div>
            <button type="button" onclick="addPhase()">Add Phase</button>
          </div>
          
          <div class="form-actions">
            <button onclick="saveProfile()">Save Profile</button>
            <button onclick="cancelProfileForm()">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>
