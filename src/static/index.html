<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Temperature Dashboard</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let interval = null;

    function updateTemp() {
      fetch('/temperature')
        .then(res => res.json())
        .then(data => {
          document.getElementById("currentTemp").innerText = data.temp + " ¬∞C";
          
          // Display target temperature or "--" if not set
          const targetDisplay = data.target !== null ? data.target + " ¬∞C" : "--";
          document.getElementById("currentTarget").innerText = targetDisplay;

          // Update profile status if available
          if (data.profile_status) {
            const status = data.profile_status;
            const statusText = status.active ? 
              `Running: ${status.profile_name} (${status.current_phase})` : 
              'Stopped';
            document.getElementById("profileStatus").innerText = statusText;
            
            // Update timer display
            const timerDiv = document.getElementById("profileTimer");
            if (status.active) {
              timerDiv.style.display = "block";
              
              // Format time as MM:SS
              const formatTime = (minutes) => {
                const mins = Math.floor(minutes);
                const secs = Math.floor((minutes - mins) * 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
              };
              
              document.getElementById("elapsedTime").innerText = formatTime(status.elapsed_minutes);
              
              const remaining = Math.max(0, status.total_minutes - status.elapsed_minutes);
              document.getElementById("remainingTime").innerText = formatTime(remaining);
              
              // Update progress bar
              const progressFill = document.getElementById("progressFill");
              progressFill.style.width = `${status.progress_percent}%`;
            } else {
              timerDiv.style.display = "none";
            }
          }

          const heaterIcon = document.getElementById("heaterStatus");
          if (data.heater_on) {
            heaterIcon.style.display = "inline";
          } else {
            heaterIcon.style.display = "none";
          }
        })
        .catch(error => {
          console.error('Error fetching temperature:', error);
          document.getElementById("currentTemp").innerText = "Error";
          document.getElementById("currentTarget").innerText = "Error";
        });
    }

    function loadProfiles() {
      return fetch('/profiles')
        .then(res => res.json())
        .then(data => {
          if (data.status === 'ok') {
            const select = document.getElementById("profileSelect");
            // Clear existing options except the first one
            select.innerHTML = '<option value="">Select a profile...</option>';
            
            // Add each profile as an option
            data.profiles.forEach(profile => {
              const option = document.createElement("option");
              option.value = profile;
              option.textContent = profile;
              select.appendChild(option);
            });
          } else {
            console.error('Profiles response error:', data);
          }
        })
        .catch(error => {
          console.error('Error loading profiles:', error);
          throw error; // Re-throw so retry logic can catch it
        });
    }

    function startProfile() {
      const select = document.getElementById("profileSelect");
      const profileName = select.value;
      
      if (!profileName) {
        showFeedback('Please select a profile first', 'error');
        return;
      }
      
      fetch('/profile/start?name=' + encodeURIComponent(profileName))
        .then(res => res.json())
        .then(data => {
          if (data.status === 'ok') {
            showFeedback(data.message, 'success');
            // Show graph and load profile data
            loadProfileForGraph(profileName);
            showTemperatureGraph();
          } else {
            showFeedback(data.message || 'Error starting profile', 'error');
          }
        })
        .catch(error => {
          console.error('Error starting profile:', error);
          showFeedback('Network error starting profile', 'error');
        });
    }

    function stopProfile() {
      fetch('/profile/stop')
        .then(res => res.json())
        .then(data => {
          if (data.status === 'ok') {
            showFeedback(data.message, 'success');
            // Hide graph when profile stops
            hideTemperatureGraph();
          } else {
            showFeedback(data.message || 'Error stopping profile', 'error');
          }
        })
        .catch(error => {
          console.error('Error stopping profile:', error);
          showFeedback('Network error stopping profile', 'error');
        });
    }

    let phaseCounter = 0;

    function toggleProfileForm() {
      const form = document.getElementById("profileForm");
      const btn = document.getElementById("toggleFormBtn");
      
      if (form.style.display === "none") {
        form.style.display = "block";
        btn.textContent = "Hide Form";
        // Add initial phase
        if (document.getElementById("phasesList").children.length === 0) {
          addPhase();
        }
      } else {
        form.style.display = "none";
        btn.textContent = "Create New Profile";
      }
    }

    function addPhase() {
      phaseCounter++;
      const phasesList = document.getElementById("phasesList");
      
      const phaseDiv = document.createElement("div");
      phaseDiv.className = "phase-item";
      phaseDiv.innerHTML = `
        <h5>Phase ${phaseCounter}</h5>
        <div class="phase-fields">
          <div class="field-group">
            <label>Name:</label>
            <input type="text" class="phase-name" placeholder="Phase name" value="Phase ${phaseCounter}">
          </div>
          <div class="field-group">
            <label>Start Temp (¬∞C):</label>
            <input type="number" class="phase-start-temp" placeholder="25" step="0.1">
          </div>
          <div class="field-group">
            <label>End Temp (¬∞C):</label>
            <input type="number" class="phase-end-temp" placeholder="50" step="0.1">
          </div>
          <div class="field-group">
            <label>Duration (minutes):</label>
            <input type="number" class="phase-duration" placeholder="5" step="0.1" min="0.1">
          </div>
          <button type="button" onclick="removePhase(this)" class="remove-phase-btn">Remove</button>
        </div>
      `;
      
      phasesList.appendChild(phaseDiv);
    }

    function removePhase(button) {
      button.closest('.phase-item').remove();
    }

    function saveProfile() {
      const profileName = document.getElementById("profileName").value.trim();
      
      if (!profileName) {
        showFeedback('Please enter a profile name', 'error');
        return;
      }
      
      // Collect phase data
      const phaseItems = document.querySelectorAll('.phase-item');
      const phases = [];
      
      for (let i = 0; i < phaseItems.length; i++) {
        const item = phaseItems[i];
        const name = item.querySelector('.phase-name').value.trim();
        const startTemp = parseFloat(item.querySelector('.phase-start-temp').value);
        const endTemp = parseFloat(item.querySelector('.phase-end-temp').value);
        const duration = parseFloat(item.querySelector('.phase-duration').value);
        
        if (!name || isNaN(startTemp) || isNaN(endTemp) || isNaN(duration) || duration <= 0) {
          showFeedback(`Please fill all fields for ${name || 'Phase ' + (i + 1)}`, 'error');
          return;
        }
        
        phases.push({
          name: name,
          start_temp: startTemp,
          end_temp: endTemp,
          duration_minutes: duration,
          type: 'time_based'
        });
      }
      
      if (phases.length === 0) {
        showFeedback('Please add at least one phase', 'error');
        return;
      }
      
      // Send to server using individual parameters for MicroPython URL limits
      let url = '/profile/create?name=' + encodeURIComponent(profileName);
      
      // Add each phase as separate parameters
      for (let i = 0; i < phases.length; i++) {
        const phase = phases[i];
        url += '&phase_' + i + '_name=' + encodeURIComponent(phase.name);
        url += '&phase_' + i + '_start=' + phase.start_temp;
        url += '&phase_' + i + '_end=' + phase.end_temp;
        url += '&phase_' + i + '_duration=' + phase.duration_minutes;
      }
      
      fetch(url)
      .then(res => res.json())
      .then(data => {
        if (data.status === 'ok') {
          showFeedback('Profile created successfully!', 'success');
          cancelProfileForm();
          
          // Simple approach: wait a bit and reload profiles
          setTimeout(() => {
            loadProfiles().then(() => {
              const select = document.getElementById("profileSelect");
              
              // Check if our new profile appears in the dropdown
              const profileExists = Array.from(select.options).some(option => 
                option.value === profileName
              );
              
              if (!profileExists) {
                console.warn('New profile not immediately visible in dropdown');
              }
            }).catch(error => {
              console.error('Error reloading profiles:', error);
              showFeedback('Error refreshing profile list', 'error');
            });
          }, 300);
          
        } else {
          showFeedback(data.message || 'Error creating profile', 'error');
        }
      })
      .catch(error => {
        console.error('Error creating profile:', error);
        showFeedback('Network error creating profile', 'error');
      });
    }

    function cancelProfileForm() {
      document.getElementById("profileForm").style.display = "none";
      document.getElementById("toggleFormBtn").textContent = "Create New Profile";
      
      // Clear form
      document.getElementById("profileName").value = "";
      document.getElementById("phasesList").innerHTML = "";
      phaseCounter = 0;
    }

    function showFeedback(message, type) {
      // Create or update feedback element
      let feedback = document.getElementById("feedback");
      if (!feedback) {
        feedback = document.createElement("div");
        feedback.id = "feedback";
        feedback.style.cssText = `
          margin: 10px 0;
          padding: 10px;
          border-radius: 4px;
          text-align: center;
          font-weight: bold;
        `;
        document.querySelector(".container").appendChild(feedback);
      }
      
      feedback.textContent = message;
      feedback.className = type; // 'success' or 'error'
      
      if (type === 'success') {
        feedback.style.backgroundColor = '#d4edda';
        feedback.style.color = '#155724';
        feedback.style.border = '1px solid #c3e6cb';
      } else {
        feedback.style.backgroundColor = '#f8d7da';
        feedback.style.color = '#721c24';
        feedback.style.border = '1px solid #f5c6cb';
      }
      
      // Clear feedback after 3 seconds
      setTimeout(() => {
        feedback.textContent = '';
        feedback.style.display = 'none';
      }, 3000);
      
      feedback.style.display = 'block';
    }

    // Temperature graphing functionality
    let temperatureChart = null;
    let profileData = null;
    let graphUpdateCounter = 0;

    function createTemperatureChart() {
      const ctx = document.getElementById('temperatureChart').getContext('2d');
      
      temperatureChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Target',
            data: [],
            borderColor: 'rgb(255, 99, 132)',
            backgroundColor: 'rgba(255, 99, 132, 0.1)',
            borderWidth: 1.5,
            fill: false,
            pointRadius: 0,
            tension: 0.1
          }, {
            label: 'Measured',
            data: [],
            borderColor: 'rgb(54, 162, 235)',
            backgroundColor: 'rgba(54, 162, 235, 0.1)',
            borderWidth: 1.5,
            fill: false,
            pointRadius: 1,
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              top: 5,
              right: 5,
              bottom: 5,
              left: 5
            }
          },
          scales: {
            x: {
              type: 'linear',
              position: 'bottom',
              title: {
                display: true,
                text: 'Time (min)',
                font: {
                  size: 10
                }
              },
              ticks: {
                font: {
                  size: 9
                }
              },
              grid: {
                display: true,
                lineWidth: 0.5
              }
            },
            y: {
              title: {
                display: true,
                text: '¬∞C',
                font: {
                  size: 10
                }
              },
              ticks: {
                font: {
                  size: 9
                }
              },
              grid: {
                display: true,
                lineWidth: 0.5
              }
            }
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                font: {
                  size: 10
                },
                padding: 8,
                usePointStyle: true,
                pointStyle: 'line'
              }
            }
          }
        }
      });
    }

    function loadProfileForGraph(profileName) {
      fetch('/profile/data?name=' + encodeURIComponent(profileName))
        .then(res => {
          if (!res.ok) {
            throw new Error('Network response was not ok');
          }
          return res.json();
        })
        .then(data => {
          if (data.status === 'ok') {
            profileData = data.data;
            updateProfileGraph();
          } else {
            console.error('Profile data error:', data.message);
          }
        })
        .catch(error => {
          console.warn('Profile data loading failed:', error.message);
          // Hide graph if we can't load profile data
          hideTemperatureGraph();
        });
    }

    function updateProfileGraph() {
      if (!temperatureChart || !profileData) return;

      // Update target temperature line
      const targetData = profileData.points.map(point => ({
        x: point.time,
        y: point.temperature
      }));
      
      temperatureChart.data.datasets[0].data = targetData;
      temperatureChart.update('none');
    }

    function updateMeasuredTemperature() {
      if (!temperatureChart) return;

      fetch('/temperature/data')
        .then(res => {
          if (!res.ok) {
            throw new Error('Network response was not ok');
          }
          return res.json();
        })
        .then(data => {
          if (data.status === 'ok' && data.profile_active) {
            const measuredData = data.data.map(point => ({
              x: point.time,
              y: point.temperature
            }));
            
            temperatureChart.data.datasets[1].data = measuredData;
            temperatureChart.update('none');
          } else if (!data.profile_active) {
            // Clear measured data and hide graph when profile is not active
            temperatureChart.data.datasets[1].data = [];
            temperatureChart.update('none');
            hideTemperatureGraph();
          }
        })
        .catch(error => {
          console.warn('Temperature data update failed (will retry):', error.message);
          // Don't show user error for this - just log and continue
        });
    }

    function showTemperatureGraph() {
      document.getElementById('temperatureGraphContainer').style.display = 'block';
    }

    function hideTemperatureGraph() {
      document.getElementById('temperatureGraphContainer').style.display = 'none';
      if (temperatureChart) {
        temperatureChart.data.datasets[0].data = [];
        temperatureChart.data.datasets[1].data = [];
        temperatureChart.update('none');
      }
      profileData = null;
    }

    window.onload = () => {
      updateTemp();
      loadProfiles();
      createTemperatureChart();
      interval = setInterval(() => {
        updateTemp();
        
        // Update graph much less frequently to reduce memory pressure
        // Every 6th update = every 12 seconds
        graphUpdateCounter++;
        if (graphUpdateCounter >= 6) {
          updateMeasuredTemperature();
          graphUpdateCounter = 0;
        }
      }, 2000);
    };
  </script>
</head>

<body>
  <div class="container">
    <h1>Temperature</h1>
  
    <div class="temperature">
      <div class="temp-wrapper">
        <span id="currentTemp">--</span>
        <span id="heaterStatus">üî•</span>
      </div>
    </div>

    <div class="target-display">
      <label>Current Target: <span id="currentTarget">--</span></label>
    </div>

    <div class="profile-section">
      <h2>Temperature Profile Status:</h2>
      
      <div class="profile-status">
        <label><span id="profileStatus">--</span></label>
        <div id="profileTimer" class="profile-timer" style="display: none;">
          <div class="timer-row">
            <span class="timer-label">Elapsed:</span>
            <span id="elapsedTime">--</span>
          </div>
          <div class="timer-row">
            <span class="timer-label">Remaining:</span>
            <span id="remainingTime">--</span>
          </div>
          <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          
          <!-- Temperature Graph integrated in the same section -->
          <div id="temperatureGraphContainer" class="temperature-graph-compact" style="display: none;">
            <div class="chart-container-compact">
              <canvas id="temperatureChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      
      <div class="profile-controls">
        <select id="profileSelect">
          <option value="">Select a profile...</option>
        </select>
      </div>
      
      <div class="profile-actions">
        <div class="control-buttons">
          <button onclick="startProfile()" id="playBtn" class="control-btn play-btn">‚ñ∂</button>
          <button onclick="stopProfile()" id="stopBtn" class="control-btn stop-btn">‚è∏</button>
        </div>
        <button onclick="toggleProfileForm()" id="toggleFormBtn" class="create-profile-btn">Create New Profile</button>
      </div>
      
      <div class="profile-creator">
        <div id="profileForm" class="profile-form" style="display: none;">
          <h3>Create New Profile</h3>
          
          <div class="form-group">
            <label for="profileName">Profile Name:</label>
            <input type="text" id="profileName" placeholder="Enter profile name">
          </div>
          
          <div class="phases-container">
            <h4>Phases:</h4>
            <div id="phasesList">
              <!-- Phases will be added here dynamically -->
            </div>
            <button type="button" onclick="addPhase()">Add Phase</button>
          </div>
          
          <div class="form-actions">
            <button onclick="saveProfile()">Save Profile</button>
            <button onclick="cancelProfileForm()">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>
