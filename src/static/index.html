<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Temperature Dashboard</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let interval = null;
    let temperatureInterval = null; // For graph updates
    let currentGraphProfile = '';
    let isGraphSynced = false;
    let wasProfileActive = false; // Track previous profile state

    function handleGraphSync(data) {
      console.log('Graph sync check:', data.graph_active, data.graph_profile, 'Current chart:', !!temperatureChart);
      
      // Check if we need to sync the graph state across clients
      if (data.graph_active && data.graph_profile) {
        // Server says a profile is running and graph should be active
        if (!temperatureChart || currentGraphProfile !== data.graph_profile) {
          // Check if this is a sync from another client (graph wasn't already running)
          const wasNotRunning = !temperatureChart;
          
          console.log('Showing graph for profile:', data.graph_profile, 'Was not running:', wasNotRunning);
          
          // We need to show the graph for this profile
          currentGraphProfile = data.graph_profile;
          loadProfileForGraph(data.graph_profile);
          showTemperatureGraph();
          isGraphSynced = true;
          
          // Start temperature graph updates for synced graphs too
          if (temperatureInterval) {
            clearInterval(temperatureInterval);
          }
          temperatureInterval = setInterval(updateMeasuredTemperature, 12000); // Every 12 seconds
          
          // Show a message if this was started from another client
          if (wasNotRunning) {
            showFeedback(`Graph synchronized - Profile "${data.graph_profile}" running from another device`, 'info');
          }
        }
      } else if (!data.graph_active && temperatureChart && document.getElementById('graphControls').style.display !== 'block') {
        // Server says no profile is running, but we have a graph AND clear button isn't already shown
        // This means profile was stopped, show clear button
        console.log('Profile stopped by sync, showing clear button');
        if (temperatureInterval) {
          clearInterval(temperatureInterval);
          temperatureInterval = null;
        }
        document.getElementById('graphControls').style.display = 'block';
      }
    }

    function updateTemp() {
      fetch('/temperature')
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          console.log('Temperature data received:', data); // Debug log
          
          // Update temperature display with proper fallbacks
          const currentTemp = data.temp !== undefined && data.temp !== null ? data.temp : '--';
          document.getElementById("currentTemp").innerText = currentTemp + (currentTemp !== '--' ? ' ¬∞C' : '');
          
          // Display target temperature or "--" if not set
          const targetTemp = data.target !== undefined && data.target !== null ? data.target : '--';
          const targetDisplay = targetTemp !== '--' ? targetTemp + " ¬∞C" : "--";
          document.getElementById("currentTarget").innerText = targetDisplay;

          // Handle graph synchronization across clients
          try {
            handleGraphSync(data);
          } catch (error) {
            console.warn('Graph sync error:', error);
          }

          // Update profile status if available
          try {
            if (data.profile_status && typeof data.profile_status === 'object') {
              const status = data.profile_status;
              const statusText = status.active ? 
                `Running: ${status.profile_name || 'Unknown'} (${status.current_phase || 'Unknown'})` : 
                'Stopped';
              document.getElementById("profileStatus").innerText = statusText;
              
              // Check if profile just finished (was active, now inactive)
              if (wasProfileActive && !status.active && temperatureChart) {
                console.log('Profile completed, showing clear button');
                if (temperatureInterval) {
                  clearInterval(temperatureInterval);
                  temperatureInterval = null;
                }
                document.getElementById('graphControls').style.display = 'block';
              }
              
              // Update the tracking variable
              wasProfileActive = status.active;
              
              // Update timer display
              const timerDiv = document.getElementById("profileTimer");
              if (status.active) {
                timerDiv.style.display = "block";
                
                // Format time as MM:SS
                const formatTime = (minutes) => {
                  const mins = Math.floor(minutes);
                  const secs = Math.floor((minutes - mins) * 60);
                  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                };
                
                document.getElementById("elapsedTime").innerText = formatTime(status.elapsed_minutes || 0);
                
                const remaining = Math.max(0, (status.total_minutes || 0) - (status.elapsed_minutes || 0));
                document.getElementById("remainingTime").innerText = formatTime(remaining);
                
                // Update progress bar
                const progressFill = document.getElementById("progressFill");
                progressFill.style.width = `${status.progress_percent || 0}%`;
              } else {
                timerDiv.style.display = "none";
              }
            } else {
              // No profile status - ensure we show "Stopped"
              document.getElementById("profileStatus").innerText = 'Stopped';
              wasProfileActive = false;
            }
          } catch (error) {
            console.warn('Profile status update error:', error);
            document.getElementById("profileStatus").innerText = 'Stopped';
            wasProfileActive = false;
          }

          // Update heater icon
          try {
            const heaterIcon = document.getElementById("heaterStatus");
            if (data.heater_on) {
              heaterIcon.style.display = "inline";
            } else {
              heaterIcon.style.display = "none";
            }
          } catch (error) {
            console.warn('Heater status update error:', error);
          }
        })
        .catch(error => {
          console.error('Error fetching temperature:', error);
          
          // Show user-friendly error messages
          if (error.message.includes('HTTP 404')) {
            document.getElementById("profileStatus").innerText = "Server not configured";
          } else if (error.message.includes('HTTP 500')) {
            document.getElementById("profileStatus").innerText = "Server error";
          } else if (error.message.includes('fetch') || error.name === 'TypeError') {
            document.getElementById("profileStatus").innerText = "Device offline";
            document.getElementById("currentTemp").innerText = "--";
            document.getElementById("currentTarget").innerText = "--";
          } else {
            // For parsing or other errors, show specific error but keep trying
            console.warn('Temperature data parsing error:', error.message);
            document.getElementById("profileStatus").innerText = "Data error";
          }
        });
    }

    function loadProfiles() {
      return fetch('/profiles')
        .then(res => res.json())
        .then(data => {
          if (data.status === 'ok') {
            const select = document.getElementById("profileSelect");
            // Clear existing options except the first one
            select.innerHTML = '<option value="">Select a profile...</option>';
            
            // Add each profile as an option
            data.profiles.forEach(profile => {
              const option = document.createElement("option");
              option.value = profile;
              option.textContent = profile;
              select.appendChild(option);
            });
          } else {
            console.error('Profiles response error:', data);
          }
        })
        .catch(error => {
          console.error('Error loading profiles:', error);
          throw error; // Re-throw so retry logic can catch it
        });
    }

    function startProfile() {
      const select = document.getElementById("profileSelect");
      const profileName = select.value;
      
      if (!profileName) {
        showFeedback('Please select a profile first', 'error');
        return;
      }
      
      fetch('/profile/start?name=' + encodeURIComponent(profileName))
        .then(res => res.json())
        .then(data => {
          if (data.status === 'ok') {
            showFeedback(data.message, 'success');
            console.log('Profile started, showing graph for:', profileName);
            // Show graph and load profile data
            currentGraphProfile = profileName;
            loadProfileForGraph(profileName);
            showTemperatureGraph();
            isGraphSynced = false; // This was started locally, not synced
            
            // Start temperature graph updates
            if (temperatureInterval) {
              clearInterval(temperatureInterval);
            }
            temperatureInterval = setInterval(updateMeasuredTemperature, 12000); // Every 12 seconds
          } else {
            showFeedback(data.message || 'Error starting profile', 'error');
          }
        })
        .catch(error => {
          console.error('Error starting profile:', error);
          showFeedback('Network error starting profile', 'error');
        });
    }

    function stopProfile() {
      console.log('Stop button clicked');
      fetch('/profile/stop')
        .then(response => {
          console.log('Stop response status:', response.status, 'OK:', response.ok);
          console.log('Response headers:', response.headers);
          if (!response.ok) {
            return response.text().then(text => {
              console.error('Stop response error text:', text);
              throw new Error(`HTTP ${response.status}: ${text}`);
            });
          }
          return response.json();
        })
        .then(data => {
          console.log('Profile stopped successfully:', data);
          showFeedback(data.message || 'Profile stopped', 'success');
          
          if (temperatureInterval) {
            console.log('Clearing temperature interval');
            clearInterval(temperatureInterval);
            temperatureInterval = null;
          }
          
          if (temperatureChart) {
            // Show the clear button instead of hiding the chart immediately
            console.log('Showing clear button after manual stop');
            document.getElementById('graphControls').style.display = 'block';
          }
        })
        .catch(error => {
          console.error('Error stopping profile:', error);
          showFeedback('Network error stopping profile', 'error');
        });
    }

    function clearGraph() {
      if (temperatureChart) {
        // Call server to clear the data
        fetch('/profile/clear', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            console.log('Graph data cleared on server:', data);
            // Now clear the client-side graph
            temperatureChart.destroy();
            temperatureChart = null;
            document.getElementById('temperatureGraphContainer').style.display = 'none';
            document.getElementById('graphControls').style.display = 'none';
            currentGraphProfile = '';
            isGraphSynced = false;
          })
          .catch(error => {
            console.error('Error clearing graph data:', error);
            // Clear client-side anyway
            temperatureChart.destroy();
            temperatureChart = null;
            document.getElementById('temperatureGraphContainer').style.display = 'none';
            document.getElementById('graphControls').style.display = 'none';
            currentGraphProfile = '';
            isGraphSynced = false;
          });
      }
    }

    let phaseCounter = 0;

    function toggleProfileForm() {
      const form = document.getElementById("profileForm");
      const btn = document.getElementById("toggleFormBtn");
      
      if (form.style.display === "none") {
        form.style.display = "block";
        btn.textContent = "Hide Form";
        // Add initial phase
        if (document.getElementById("phasesList").children.length === 0) {
          addPhase();
        }
      } else {
        form.style.display = "none";
        btn.textContent = "Create New Profile";
      }
    }

    function addPhase() {
      phaseCounter++;
      const phasesList = document.getElementById("phasesList");
      
      const phaseDiv = document.createElement("div");
      phaseDiv.className = "phase-item";
      phaseDiv.innerHTML = `
        <h5>Phase ${phaseCounter}</h5>
        <div class="phase-fields">
          <div class="field-group">
            <label>Name:</label>
            <input type="text" class="phase-name" placeholder="Phase name" value="Phase ${phaseCounter}">
          </div>
          <div class="field-group">
            <label>Start Temp (¬∞C):</label>
            <input type="number" class="phase-start-temp" placeholder="25" step="0.1">
          </div>
          <div class="field-group">
            <label>End Temp (¬∞C):</label>
            <input type="number" class="phase-end-temp" placeholder="50" step="0.1">
          </div>
          <div class="field-group">
            <label>Duration (minutes):</label>
            <input type="number" class="phase-duration" placeholder="5" step="0.1" min="0.1">
          </div>
          <button type="button" onclick="removePhase(this)" class="remove-phase-btn">Remove</button>
        </div>
      `;
      
      phasesList.appendChild(phaseDiv);
    }

    function removePhase(button) {
      button.closest('.phase-item').remove();
    }

    function saveProfile() {
      const profileName = document.getElementById("profileName").value.trim();
      
      if (!profileName) {
        showFeedback('Please enter a profile name', 'error');
        return;
      }
      
      // Collect phase data
      const phaseItems = document.querySelectorAll('.phase-item');
      const phases = [];
      
      for (let i = 0; i < phaseItems.length; i++) {
        const item = phaseItems[i];
        const name = item.querySelector('.phase-name').value.trim();
        const startTemp = parseFloat(item.querySelector('.phase-start-temp').value);
        const endTemp = parseFloat(item.querySelector('.phase-end-temp').value);
        const duration = parseFloat(item.querySelector('.phase-duration').value);
        
        if (!name || isNaN(startTemp) || isNaN(endTemp) || isNaN(duration) || duration <= 0) {
          showFeedback(`Please fill all fields for ${name || 'Phase ' + (i + 1)}`, 'error');
          return;
        }
        
        phases.push({
          name: name,
          start_temp: startTemp,
          end_temp: endTemp,
          duration_minutes: duration,
          type: 'time_based'
        });
      }
      
      if (phases.length === 0) {
        showFeedback('Please add at least one phase', 'error');
        return;
      }
      
      // Send to server using individual parameters for MicroPython URL limits
      let url = '/profile/create?name=' + encodeURIComponent(profileName);
      
      // Add each phase as separate parameters
      for (let i = 0; i < phases.length; i++) {
        const phase = phases[i];
        url += '&phase_' + i + '_name=' + encodeURIComponent(phase.name);
        url += '&phase_' + i + '_start=' + phase.start_temp;
        url += '&phase_' + i + '_end=' + phase.end_temp;
        url += '&phase_' + i + '_duration=' + phase.duration_minutes;
      }
      
      fetch(url)
      .then(res => res.json())
      .then(data => {
        if (data.status === 'ok') {
          showFeedback('Profile created successfully!', 'success');
          cancelProfileForm();
          
          // Simple approach: wait a bit and reload profiles
          setTimeout(() => {
            loadProfiles().then(() => {
              const select = document.getElementById("profileSelect");
              
              // Check if our new profile appears in the dropdown
              const profileExists = Array.from(select.options).some(option => 
                option.value === profileName
              );
              
              if (!profileExists) {
                console.warn('New profile not immediately visible in dropdown');
              }
            }).catch(error => {
              console.error('Error reloading profiles:', error);
              showFeedback('Error refreshing profile list', 'error');
            });
          }, 300);
          
        } else {
          showFeedback(data.message || 'Error creating profile', 'error');
        }
      })
      .catch(error => {
        console.error('Error creating profile:', error);
        showFeedback('Network error creating profile', 'error');
      });
    }

    function cancelProfileForm() {
      document.getElementById("profileForm").style.display = "none";
      document.getElementById("toggleFormBtn").textContent = "Create New Profile";
      
      // Clear form
      document.getElementById("profileName").value = "";
      document.getElementById("phasesList").innerHTML = "";
      phaseCounter = 0;
    }

    function showFeedback(message, type) {
      // Create or update feedback element
      let feedback = document.getElementById("feedback");
      if (!feedback) {
        feedback = document.createElement("div");
        feedback.id = "feedback";
        feedback.style.cssText = `
          margin: 10px 0;
          padding: 10px;
          border-radius: 4px;
          text-align: center;
          font-weight: bold;
        `;
        document.querySelector(".container").appendChild(feedback);
      }
      
      feedback.textContent = message;
      feedback.className = type; // 'success', 'error', or 'info'
      
      if (type === 'success') {
        feedback.style.backgroundColor = '#d4edda';
        feedback.style.color = '#155724';
        feedback.style.border = '1px solid #c3e6cb';
      } else if (type === 'info') {
        feedback.style.backgroundColor = '#d1ecf1';
        feedback.style.color = '#0c5460';
        feedback.style.border = '1px solid #bee5eb';
      } else {
        feedback.style.backgroundColor = '#f8d7da';
        feedback.style.color = '#721c24';
        feedback.style.border = '1px solid #f5c6cb';
      }
      
      // Clear feedback after 3 seconds
      setTimeout(() => {
        feedback.textContent = '';
        feedback.style.display = 'none';
      }, 3000);
      
      feedback.style.display = 'block';
    }

    // Temperature graphing functionality
    let temperatureChart = null;
    let profileData = null;

    function createTemperatureChart() {
      const ctx = document.getElementById('temperatureChart').getContext('2d');
      
      temperatureChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Target',
            data: [],
            borderColor: 'rgb(255, 99, 132)',
            backgroundColor: 'rgba(255, 99, 132, 0.1)',
            borderWidth: 1.5,
            fill: false,
            pointRadius: 0,
            tension: 0.1
          }, {
            label: 'Measured',
            data: [],
            borderColor: 'rgb(54, 162, 235)',
            backgroundColor: 'rgba(54, 162, 235, 0.1)',
            borderWidth: 1.5,
            fill: false,
            pointRadius: 1,
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              top: 5,
              right: 5,
              bottom: 5,
              left: 5
            }
          },
          scales: {
            x: {
              type: 'linear',
              position: 'bottom',
              title: {
                display: false  // Hide the default title
              },
              ticks: {
                font: {
                  size: 9
                }
              },
              grid: {
                display: true,
                lineWidth: 0.5
              }
            },
            y: {
              title: {
                display: true,
                text: '¬∞C',
                font: {
                  size: 10
                }
              },
              ticks: {
                font: {
                  size: 9
                }
              },
              grid: {
                display: true,
                lineWidth: 0.5
              }
            }
          },
          plugins: {
            legend: {
              display: false  // We'll draw custom legend
            }
          }
        }
      });
      
      // Add custom legend and time axis label inside the chart
      Chart.register({
        id: 'customLabels',
        afterDraw: function(chart) {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          
          ctx.save();
          ctx.font = '9px Segoe UI, Roboto, sans-serif';
          ctx.fillStyle = '#666';
          
          // Draw time label in bottom right
          ctx.textAlign = 'right';
          ctx.textBaseline = 'bottom';
          ctx.fillText('Time (min)', chartArea.right - 5, chartArea.bottom - 2);
          
          // Draw custom legend in top left
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          
          const legendY = chartArea.top + 5;
          const legendX = chartArea.left + 5;
          
          // Target line legend
          ctx.strokeStyle = 'rgb(255, 99, 132)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(legendX, legendY + 5);
          ctx.lineTo(legendX + 15, legendY + 5);
          ctx.stroke();
          ctx.fillText('Target', legendX + 20, legendY);
          
          // Measured line legend
          ctx.strokeStyle = 'rgb(54, 162, 235)';
          ctx.beginPath();
          ctx.moveTo(legendX + 70, legendY + 5);
          ctx.lineTo(legendX + 85, legendY + 5);
          ctx.stroke();
          ctx.fillText('Measured', legendX + 90, legendY);
          
          ctx.restore();
        }
      });
    }

    function loadProfileForGraph(profileName) {
      fetch('/profile/data?name=' + encodeURIComponent(profileName))
        .then(res => {
          if (!res.ok) {
            throw new Error('Network response was not ok');
          }
          return res.json();
        })
        .then(data => {
          if (data.status === 'ok') {
            profileData = data.data;
            updateProfileGraph();
          } else {
            console.error('Profile data error:', data.message);
          }
        })
        .catch(error => {
          console.warn('Profile data loading failed:', error.message);
          // Hide graph if we can't load profile data
          hideTemperatureGraph();
        });
    }

    function updateProfileGraph() {
      if (!temperatureChart || !profileData) return;

      // Update target temperature line
      const targetData = profileData.points.map(point => ({
        x: point.time,
        y: point.temperature
      }));
      
      temperatureChart.data.datasets[0].data = targetData;
      temperatureChart.update('none');
    }

    function updateMeasuredTemperature() {
      if (!temperatureChart) return;

      fetch('/temperature/data')
        .then(res => {
          if (!res.ok) {
            throw new Error('Network response was not ok');
          }
          return res.json();
        })
        .then(data => {
          if (data.status === 'ok' && data.profile_active) {
            const measuredData = data.data.map(point => ({
              x: point.time,
              y: point.temperature
            }));
            
            temperatureChart.data.datasets[1].data = measuredData;
            temperatureChart.update('none');
          } else if (!data.profile_active) {
            // Just clear measured data when profile is not active, don't hide graph
            temperatureChart.data.datasets[1].data = [];
            temperatureChart.update('none');
            // Don't call hideTemperatureGraph() here - let handleGraphSync manage it
          }
        })
        .catch(error => {
          console.warn('Temperature data update failed (will retry):', error.message);
          // Don't show user error for this - just log and continue
        });
    }

    function showTemperatureGraph() {
      document.getElementById('temperatureGraphContainer').style.display = 'block';
    }

    function hideTemperatureGraph() {
      document.getElementById('temperatureGraphContainer').style.display = 'none';
      if (temperatureChart) {
        temperatureChart.data.datasets[0].data = [];
        temperatureChart.data.datasets[1].data = [];
        temperatureChart.update('none');
      }
      profileData = null;
    }

    window.onload = () => {
      // Test basic connectivity first
      console.log('Testing server connectivity...');
      fetch('/temperature')
        .then(res => {
          console.log('Server response status:', res.status);
          if (res.ok) {
            console.log('Server connectivity: OK');
            // Server is working, start normal operations
            updateTemp();
            loadProfiles();
            createTemperatureChart();
            interval = setInterval(updateTemp, 2000);
          } else {
            console.error('Server connectivity: FAILED - HTTP', res.status);
            document.getElementById("profileStatus").innerText = `Server Error ${res.status}`;
            document.getElementById("currentTemp").innerText = "--";
            document.getElementById("currentTarget").innerText = "--";
          }
        })
        .catch(error => {
          console.error('Server connectivity: FAILED -', error.message);
          document.getElementById("profileStatus").innerText = 'Device Offline - Check MicroPython';
          document.getElementById("currentTemp").innerText = "--";
          document.getElementById("currentTarget").innerText = "--";
          
          // Try to start basic chart anyway for when server comes online
          createTemperatureChart();
        });
    };
  </script>
</head>

<body>
  <div class="container">
    <h1>Temperature</h1>
  
    <div class="temperature-display">
      <div class="temp-section">
        <div class="temp-value">
          <span id="currentTemp">--</span>
          <span id="heaterStatus">üî•</span>
        </div>
        <div class="temp-label">Current</div>
      </div>
      
      <div class="target-section">
        <div class="temp-value">
          <span id="currentTarget">--</span>
        </div>
        <div class="temp-label">Target</div>
      </div>
    </div>

    <div class="profile-section">
      <h2>Temperature Profile Status:</h2>
      
      <div class="profile-status">
        <label><span id="profileStatus">--</span></label>
        <div id="profileTimer" class="profile-timer" style="display: none;">
          <div class="timer-row">
            <span class="timer-label">Elapsed:</span>
            <span id="elapsedTime">--</span>
          </div>
          <div class="timer-row">
            <span class="timer-label">Remaining:</span>
            <span id="remainingTime">--</span>
          </div>
          <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          
          <!-- Temperature Graph integrated in the same section -->
          <div id="temperatureGraphContainer" class="temperature-graph-compact" style="display: none;">
            <div class="chart-container-compact">
              <canvas id="temperatureChart"></canvas>
            </div>
            <div id="graphControls" class="graph-controls" style="display: none;">
              <button id="clearButton" onclick="clearGraph()" class="clear-graph-btn">Clear Graph</button>
            </div>
          </div>
        </div>
      </div>
      
      <div class="profile-controls">
        <select id="profileSelect">
          <option value="">Select a profile...</option>
        </select>
      </div>
      
      <div class="profile-actions">
        <div class="control-buttons">
          <button onclick="startProfile()" id="playBtn" class="control-btn play-btn">‚ñ∂</button>
          <button onclick="stopProfile()" id="stopBtn" class="control-btn stop-btn">‚è∏</button>
        </div>
        <button onclick="toggleProfileForm()" id="toggleFormBtn" class="create-profile-btn">Create New Profile</button>
      </div>
      
      <div class="profile-creator">
        <div id="profileForm" class="profile-form" style="display: none;">
          <h3>Create New Profile</h3>
          
          <div class="form-group">
            <label for="profileName">Profile Name:</label>
            <input type="text" id="profileName" placeholder="Enter profile name">
          </div>
          
          <div class="phases-container">
            <h4>Phases:</h4>
            <div id="phasesList">
              <!-- Phases will be added here dynamically -->
            </div>
            <button type="button" onclick="addPhase()">Add Phase</button>
          </div>
          
          <div class="form-actions">
            <button onclick="saveProfile()">Save Profile</button>
            <button onclick="cancelProfileForm()">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>
